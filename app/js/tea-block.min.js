class Tea{static encrypt(e,t){if(e=String(e),t=String(t),0==e.length)return"";const r=Tea.strToLongs(Tea.utf8Encode(e)),o=Tea.strToLongs(Tea.utf8Encode(t).slice(0,16)),n=Tea.encode(r,o),a=Tea.longsToStr(n);return Tea.base64Encode(a)}static decrypt(e,t){if(e=String(e),t=String(t),0==e.length)return"";const r=Tea.strToLongs(Tea.base64Decode(e)),o=Tea.strToLongs(Tea.utf8Encode(t).slice(0,16)),n=Tea.decode(r,o),a=Tea.longsToStr(n);return Tea.utf8Decode(a.replace(/\0+$/,""))}static encode(e,t){e.length<2&&(e[1]=0);const r=e.length;let o,n,a=Math.floor(6+52/r),c=e[r-1],f=e[0],d=0;for(;a-- >0;){n=(d+=2654435769)>>>2&3;for(let a=0;a<r;a++)o=(c>>>5^(f=e[(a+1)%r])<<2)+(f>>>3^c<<4)^(d^f)+(t[3&a^n]^c),c=e[a]+=o}return e}static decode(e,t){const r=e.length,o=Math.floor(6+52/r);let n,a,c=e[r-1],f=e[0],d=2654435769*o;for(;0!=d;){a=d>>>2&3;for(let o=r-1;o>=0;o--)n=((c=e[o>0?o-1:r-1])>>>5^f<<2)+(f>>>3^c<<4)^(d^f)+(t[3&o^a]^c),f=e[o]-=n;d-=2654435769}return e}static strToLongs(e){const t=new Array(Math.ceil(e.length/4));for(let r=0;r<t.length;r++)t[r]=e.charCodeAt(4*r)+(e.charCodeAt(4*r+1)<<8)+(e.charCodeAt(4*r+2)<<16)+(e.charCodeAt(4*r+3)<<24);return t}static longsToStr(e){let t="";for(let r=0;r<e.length;r++)t+=String.fromCharCode(255&e[r],e[r]>>>8&255,e[r]>>>16&255,e[r]>>>24&255);return t}static utf8Encode(e){return unescape(encodeURIComponent(e))}static utf8Decode(e){try{return decodeURIComponent(escape(e))}catch(t){return e}}static base64Encode(e){if("undefined"!=typeof btoa)return btoa(e);if("undefined"!=typeof Buffer)return new Buffer(e,"binary").toString("base64");throw new Error("No Base64 Encode")}static base64Decode(e){if("undefined"==typeof atob&&"undefined"==typeof Buffer)throw new Error("No base64 decode");try{if("undefined"!=typeof atob)return atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString("binary")}catch(e){throw new Error("Invalid ciphertext")}}}export default Tea;
